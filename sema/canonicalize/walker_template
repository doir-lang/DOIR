#include "../module.hpp"
#include "../interface.hpp"

namespace doir {
	void tree_walker(module& mod, ecrs::entity_t subtree) {

		if(mod.has_component<type_of>(subtree) || mod.has_component<lookup::type_of>(subtree)) {
			lookup::type_of t = mod.has_component<type_of>(subtree)
				? lookup::type_of(mod.get_component<type_of>(subtree).related[0])
				: mod.get_component<lookup::type_of>(subtree);

			if(t.resolved())
				tree_walker(mod, t.entity());

			bool valueless = mod.has_component<doir::flags>(subtree) && mod.get_component<doir::flags>(subtree).valueless_set();
			bool number = mod.has_component<doir::number>(subtree);
			bool string = mod.has_component<doir::string>(subtree);
			bool call = mod.has_component<doir::call>(subtree);
			bool call_lookup = mod.has_component<doir::lookup::call>(subtree);
			bool function_def = mod.has_component<doir::function_return_type>(subtree);
			bool function_def_lookup = mod.has_component<doir::lookup::function_return_type>(subtree);
			bool block = mod.has_component<doir::block>(subtree);

			if(call || call_lookup) {
				doir::lookup::lookup call = mod.has_component<doir::call>(subtree)
					? doir::lookup::lookup(mod.get_component<doir::call>(subtree).related[0])
					: doir::lookup::lookup(mod.get_component<doir::lookup::call>(subtree));
				if(call.resolved())
					tree_walker(mod, call.entity());
				auto inputs = mod.has_component<doir::function_inputs>(subtree)
					? doir::lookup::function_inputs::to_lookup(mod.get_component<doir::function_inputs>(subtree))
					: mod.get_component<doir::lookup::function_inputs>(subtree);
				for(auto& i: inputs)
					if(i.resolved())
						tree_walker(mod, i.entity());

			} else if(function_def || function_def_lookup) {
				tree_walker(mod, t.entity());
			}

		} else if(mod.has_component<type_definition>(subtree)) {
			if(mod.has_component<doir::function_inputs>(subtree)) {
				auto inputs = mod.has_component<doir::function_inputs>(subtree)
					? doir::lookup::function_inputs::to_lookup(mod.get_component<doir::function_inputs>(subtree))
					: mod.get_component<doir::lookup::function_inputs>(subtree);
				std::optional<doir::lookup::function_return_type> return_type = {};
				if(mod.has_component<doir::function_return_type>(subtree))
					return_type = {mod.get_component<doir::function_return_type>(subtree).related[0]};
				else if(mod.has_component<doir::lookup::function_return_type>(subtree))
					return_type = mod.get_component<doir::lookup::function_return_type>(subtree);

				if(return_type && return_type->resolved())
					tree_walker(mod, return_type->entity());
				for(auto& i: inputs)
					if(i.resolved())
						tree_walker(mod, i.entity());
			}

		} else if(mod.has_component<doir::flags>(subtree) && mod.get_component<doir::flags>(subtree).namespace_set()) {

		} else if(mod.has_component<alias>(subtree) || mod.has_component<doir::lookup::alias>(subtree)) {
			auto alias = mod.has_component<doir::alias>(subtree)
				? lookup::alias(mod.get_component<doir::alias>(subtree).related[0])
				: mod.get_component<lookup::alias>(subtree);

			if(alias.resolved())
				tree_walker(mod, alias.entity());
		}

		if(mod.has_component<doir::block>(subtree)) for(auto e: mod.get_component<doir::block>(subtree).related)
			tree_walker(mod, e);
	}
}
